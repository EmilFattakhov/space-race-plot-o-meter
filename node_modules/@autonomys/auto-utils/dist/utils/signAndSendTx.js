"use strict";
// file: src/utils/signAndSendTx.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndSendTx = void 0;
const detectTxSuccess_1 = require("./detectTxSuccess");
const events_1 = require("./events");
const validateEvents_1 = require("./validateEvents");
const signAndSendTx = (sender_1, tx_1, ...args_1) => __awaiter(void 0, [sender_1, tx_1, ...args_1], void 0, function* (sender, tx, options = {}, eventsExpected = events_1.expectSuccessfulTxEvent, log = false, mapErrorCodeToEnum) {
    let success = false;
    let txHashHex = undefined;
    let blockHash = undefined;
    let eventsValidated = { expected: [], found: [] };
    let identifier = null;
    const receipt = yield new Promise((resolve, reject) => {
        tx.signAndSend(sender, options, (result) => __awaiter(void 0, void 0, void 0, function* () {
            const { events = [], status, dispatchError } = result;
            if (status.isInBlock || status.isFinalized) {
                txHashHex = result.txHash.toHex();
                blockHash = status.isInBlock ? status.asInBlock.toHex() : status.asFinalized.toHex();
                if (log)
                    console.log('Successful tx', txHashHex, 'in block', blockHash);
                success = (0, detectTxSuccess_1.detectTxSuccess)(events);
                if (eventsExpected.length > 0) {
                    const _events = (0, validateEvents_1.validateEvents)(events, eventsExpected, txHashHex, blockHash, log);
                    if (_events.expected.length === 0)
                        resolve(result);
                    else
                        reject(new Error('Events not found'));
                }
                else {
                    try {
                        events.forEach(({ event: { section, method, data } }) => {
                            if (section === 'system' && method === 'ExtrinsicFailed') {
                                const dispatchErrorJson = JSON.parse(dispatchError.toString());
                                const errorEnum = mapErrorCodeToEnum === null || mapErrorCodeToEnum === void 0 ? void 0 : mapErrorCodeToEnum(dispatchErrorJson.module.error);
                                reject(new Error(`Extrinsic failed: ${errorEnum} in block #${blockHash} with error: ${dispatchErrorJson}`));
                            }
                            if (section === 'autoId' && method === 'NewAutoIdRegistered') {
                                identifier = data[0].toString();
                            }
                        });
                        resolve(result);
                    }
                    catch (err) {
                        reject(new Error(`Failed to retrieve block information: ${err.message}`));
                    }
                }
            }
            else if (status.isRetracted ||
                status.isFinalityTimeout ||
                status.isDropped ||
                status.isInvalid) {
                if (log)
                    console.error('Transaction failed');
                reject(new Error('Transaction failed'));
            }
        }));
    });
    return { success, txHash: txHashHex, blockHash, events: eventsValidated, receipt, identifier };
});
exports.signAndSendTx = signAndSendTx;
