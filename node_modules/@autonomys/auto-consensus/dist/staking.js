"use strict";
// file: src/staking.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unlockNominator = exports.unlockFunds = exports.deregisterOperator = exports.withdrawStake = exports.nominateOperator = exports.registerOperator = exports.withdrawals = exports.deposits = exports.operator = exports.operators = void 0;
const auto_utils_1 = require("@autonomys/auto-utils");
const parse_1 = require("./utils/parse");
const operators = (api) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const _operators = yield api.query.domains.operators.entries();
        return _operators.map((o) => (0, parse_1.parseOperator)(o));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error querying operators list.' + error);
    }
});
exports.operators = operators;
const operator = (api, operatorId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const _operator = yield api.query.domains.operators((0, parse_1.parseString)(operatorId));
        return (0, parse_1.parseOperatorDetails)(_operator);
    }
    catch (error) {
        console.error('error', error);
        throw new Error(`Error querying operatorId: ${operatorId} with error: ${error}`);
    }
});
exports.operator = operator;
const deposits = (api_1, operatorId_1, ...args_1) => __awaiter(void 0, [api_1, operatorId_1, ...args_1], void 0, function* (api, operatorId, account = undefined) {
    try {
        const _deposits = yield api.query.domains.deposits.entries((0, parse_1.parseString)(operatorId), account);
        return _deposits.map((o) => (0, parse_1.parseDeposit)(o));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error querying deposits list.' + error);
    }
});
exports.deposits = deposits;
const withdrawals = (api_1, operatorId_1, ...args_1) => __awaiter(void 0, [api_1, operatorId_1, ...args_1], void 0, function* (api, operatorId, account = undefined) {
    try {
        const _withdrawals = yield api.query.domains.withdrawals.entries((0, parse_1.parseString)(operatorId), account);
        return _withdrawals.map((o) => (0, parse_1.parseWithdrawal)(o));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error querying withdrawals list.' + error);
    }
});
exports.withdrawals = withdrawals;
const registerOperator = (params) => {
    try {
        const { api, senderAddress, Operator, domainId, amountToStake, minimumNominatorStake, nominationTax, } = params;
        const message = (0, auto_utils_1.createAccountIdType)(api, senderAddress);
        const signature = Operator.sign(message);
        return api.tx.domains.registerOperator((0, parse_1.parseString)(domainId), (0, parse_1.parseString)(amountToStake), {
            signingKey: (0, auto_utils_1.signingKey)(Operator.publicKey),
            minimumNominatorStake: (0, parse_1.parseString)(minimumNominatorStake),
            nominationTax: (0, parse_1.parseString)(nominationTax),
        }, signature);
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error creating register operator tx.' + error);
    }
};
exports.registerOperator = registerOperator;
const nominateOperator = (params) => {
    try {
        const { api, operatorId, amountToStake } = params;
        return api.tx.domains.nominateOperator((0, parse_1.parseString)(operatorId), (0, parse_1.parseString)(amountToStake));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error creating nominate operator tx.' + error);
    }
};
exports.nominateOperator = nominateOperator;
const withdrawStake = (params) => {
    try {
        const { api, operatorId, shares } = params;
        return api.tx.domains.withdrawStake((0, parse_1.parseString)(operatorId), (0, parse_1.parseString)(shares));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error creating withdraw stake tx.' + error);
    }
};
exports.withdrawStake = withdrawStake;
const deregisterOperator = (params) => {
    try {
        const { api, operatorId } = params;
        return api.tx.domains.deregisterOperator((0, parse_1.parseString)(operatorId));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error creating de-register operator tx.' + error);
    }
};
exports.deregisterOperator = deregisterOperator;
const unlockFunds = (params) => {
    try {
        const { api, operatorId } = params;
        return api.tx.domains.unlockFunds((0, parse_1.parseString)(operatorId));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error creating unlock funds tx.' + error);
    }
};
exports.unlockFunds = unlockFunds;
const unlockNominator = (params) => {
    try {
        const { api, operatorId } = params;
        return api.tx.domains.unlockNominator((0, parse_1.parseString)(operatorId));
    }
    catch (error) {
        console.error('error', error);
        throw new Error('Error creating unlock nominator tx.' + error);
    }
};
exports.unlockNominator = unlockNominator;
